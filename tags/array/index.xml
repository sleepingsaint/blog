<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>array on sleepingsaint</title><link>https://sleepingsaint.github.io/blog/tags/array/</link><description>Recent content in array on sleepingsaint</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 29 Aug 2021 01:45:42 +0530</lastBuildDate><atom:link href="https://sleepingsaint.github.io/blog/tags/array/index.xml" rel="self" type="application/rss+xml"/><item><title>Longest Uncommon Subsequence</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/longest-uncommon-subsequence/</link><pubDate>Sun, 29 Aug 2021 01:45:42 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/longest-uncommon-subsequence/</guid><description>Question Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1.
An uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others.
A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.</description></item><item><title>Maximum Profit in Job Scheduling</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/maximum-profit-in-job-scheduling/</link><pubDate>Sun, 29 Aug 2021 01:09:02 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/maximum-profit-in-job-scheduling/</guid><description>Question We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].
You&amp;rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.
If you choose a job that ends at time X you will be able to start another job that starts at time X.</description></item><item><title>Range Sum Query Immutable</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/range-sum-query-immutable/</link><pubDate>Mon, 16 Aug 2021 13:24:12 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/range-sum-query-immutable/</guid><description>Question Given an integer array nums, handle multiple queries of the following type:
Calculate the sum of the elements of nums between indices left and right inclusive where left &amp;lt;= right.
Implement the NumArray class:
NumArray(int[] nums) Initializes the object with the integer array nums. int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + &amp;hellip; + nums[right]).</description></item><item><title>Remove Boxes</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/remove-boxes/</link><pubDate>Sat, 14 Aug 2021 22:30:00 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/remove-boxes/</guid><description>Question You are given several boxes with different colors represented by different positive numbers.
You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k &amp;gt;= 1), remove them and get k * k points.
Return the maximum points you can get.
Examples Input: boxes = [1,3,2,2,2,3,4,3,1]
Output: 23</description></item><item><title>Set Matrix Zeroes</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/set-matrix-zeroes/</link><pubDate>Fri, 13 Aug 2021 13:36:46 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/set-matrix-zeroes/</guid><description>Question Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s, and return the matrix.
You must do it in place.
Examples Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[1,0,1],[0,0,0],[1,0,1]]
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
Constraints m == matrix.length n == matrix[0].length 1 &amp;lt;= m, n &amp;lt;= 200 -2^31 &amp;lt;= matrix[i][j] &amp;lt;= 2^31 - 1 Explanation One approach for this problem is, we maintain two hashmap to store which row and column should be made 0.</description></item><item><title>Array of Doubled Pairs</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/array-of-doubled-pairs/</link><pubDate>Wed, 11 Aug 2021 19:53:05 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/array-of-doubled-pairs/</guid><description>Question Given an array of integers arr of even length, return true if and only if it is possible to reorder it such that arr[2 * i + 1] = 2 * arr[2 * i] for every 0 &amp;lt;= i &amp;lt; len(arr) / 2.
Examples Input: arr = [3,1,3,6]
Output: false
Input: arr = [2,1,2,6]
Output: false
Input: arr = [4,-2,2,-4]
Output: true
Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].</description></item><item><title>Flip String to Monotone Increasing</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/flip-string-to-monotone-increasing/</link><pubDate>Wed, 11 Aug 2021 09:01:38 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/flip-string-to-monotone-increasing/</guid><description>Question A binary string is monotone increasing if it consists of some number of 0&amp;rsquo;s (possibly none), followed by some number of 1&amp;rsquo;s (also possibly none).
You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.
Return the minimum number of flips to make s monotone increasing.
Examples Input: s = &amp;ldquo;00110&amp;rdquo;
Output: 1
Explanation: We flip the last digit to get 00111.</description></item><item><title>Trapping Rain Water</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/trapping-rain-water/</link><pubDate>Sat, 31 Jul 2021 13:26:43 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/trapping-rain-water/</guid><description>Question Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
Example Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Input: height = [4,2,0,3,2,5] Output: 9 Constraints Constraints:
n == height.length 0 &amp;lt;= n &amp;lt;= 3 * 104 0 &amp;lt;= height[i] &amp;lt;= 105 Explanation On any point, to trap rain water we need to have walls adjacent to the current point with elevation more than the current elevation.</description></item></channel></rss>
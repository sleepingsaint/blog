<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>array on sleepingsaint</title><link>https://sleepingsaint.github.io/blog/tags/array/</link><description>Recent content in array on sleepingsaint</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 Sep 2021 14:47:45 +0530</lastBuildDate><atom:link href="https://sleepingsaint.github.io/blog/tags/array/index.xml" rel="self" type="application/rss+xml"/><item><title>Array Nesting</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/array-nesting/</link><pubDate>Wed, 01 Sep 2021 14:47:45 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/array-nesting/</guid><description>Question You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].
You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], &amp;hellip; } subjected to the following rule:
The first element in s[k] starts with the selection of the element nums[k] of index = k. The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.</description></item><item><title>Find Minimum in Rotated Sorted Array</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/find-minimum-in-rotated-sorted-array/</link><pubDate>Tue, 31 Aug 2021 14:02:23 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/find-minimum-in-rotated-sorted-array/</guid><description>Question Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:
[4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], &amp;hellip;, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], &amp;hellip;, a[n-2]].
Given the sorted rotated array nums of unique elements, return the minimum element of this array.</description></item><item><title>Range Addition 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/range-addition-2/</link><pubDate>Mon, 30 Aug 2021 19:19:25 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/range-addition-2/</guid><description>Question You are given an m x n matrix M initialized with all 0&amp;rsquo;s and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 &amp;lt;= x &amp;lt; ai and 0 &amp;lt;= y &amp;lt; bi.
Count and return the number of maximum integers in the matrix after performing all the operations.
Examples Input: m = 3, n = 3, ops = [[2,2],[3,3]] Output: 4 Explanation: The maximum integer in M is 2, and there are four of it in M.</description></item><item><title>Patching Array</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/patching-array/</link><pubDate>Sun, 29 Aug 2021 23:10:49 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/patching-array/</guid><description>Question Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.
Return the minimum number of patches required.
Examples Input: nums = [1,3], n = 6 Output: 1 Explanation: Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.</description></item><item><title>Longest Uncommon Subsequence</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/longest-uncommon-subsequence/</link><pubDate>Sun, 29 Aug 2021 01:45:42 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/longest-uncommon-subsequence/</guid><description>Question Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1.
An uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others.
A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.</description></item><item><title>Maximum Profit in Job Scheduling</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/maximum-profit-in-job-scheduling/</link><pubDate>Sun, 29 Aug 2021 01:09:02 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/maximum-profit-in-job-scheduling/</guid><description>Question We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].
You&amp;rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.
If you choose a job that ends at time X you will be able to start another job that starts at time X.</description></item><item><title>Range Sum Query Immutable</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/range-sum-query-immutable/</link><pubDate>Mon, 16 Aug 2021 13:24:12 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/range-sum-query-immutable/</guid><description>Question Given an integer array nums, handle multiple queries of the following type:
Calculate the sum of the elements of nums between indices left and right inclusive where left &amp;lt;= right.
Implement the NumArray class:
NumArray(int[] nums) Initializes the object with the integer array nums. int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + &amp;hellip; + nums[right]).</description></item><item><title>Remove Boxes</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/remove-boxes/</link><pubDate>Sat, 14 Aug 2021 22:30:00 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/remove-boxes/</guid><description>Question You are given several boxes with different colors represented by different positive numbers.
You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k &amp;gt;= 1), remove them and get k * k points.
Return the maximum points you can get.
Examples Input: boxes = [1,3,2,2,2,3,4,3,1]
Output: 23</description></item><item><title>Set Matrix Zeroes</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/set-matrix-zeroes/</link><pubDate>Fri, 13 Aug 2021 13:36:46 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/set-matrix-zeroes/</guid><description>Question Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s, and return the matrix.
You must do it in place.
Examples Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[1,0,1],[0,0,0],[1,0,1]]
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
Constraints m == matrix.length n == matrix[0].length 1 &amp;lt;= m, n &amp;lt;= 200 -2^31 &amp;lt;= matrix[i][j] &amp;lt;= 2^31 - 1 Explanation One approach for this problem is, we maintain two hashmap to store which row and column should be made 0.</description></item><item><title>Array of Doubled Pairs</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/array-of-doubled-pairs/</link><pubDate>Wed, 11 Aug 2021 19:53:05 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/array-of-doubled-pairs/</guid><description>Question Given an array of integers arr of even length, return true if and only if it is possible to reorder it such that arr[2 * i + 1] = 2 * arr[2 * i] for every 0 &amp;lt;= i &amp;lt; len(arr) / 2.
Examples Input: arr = [3,1,3,6]
Output: false
Input: arr = [2,1,2,6]
Output: false
Input: arr = [4,-2,2,-4]
Output: true
Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].</description></item><item><title>Flip String to Monotone Increasing</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/flip-string-to-monotone-increasing/</link><pubDate>Wed, 11 Aug 2021 09:01:38 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/flip-string-to-monotone-increasing/</guid><description>Question A binary string is monotone increasing if it consists of some number of 0&amp;rsquo;s (possibly none), followed by some number of 1&amp;rsquo;s (also possibly none).
You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.
Return the minimum number of flips to make s monotone increasing.
Examples Input: s = &amp;ldquo;00110&amp;rdquo;
Output: 1
Explanation: We flip the last digit to get 00111.</description></item><item><title>Trapping Rain Water</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/trapping-rain-water/</link><pubDate>Sat, 31 Jul 2021 13:26:43 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/trapping-rain-water/</guid><description>Question Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
Example Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Input: height = [4,2,0,3,2,5] Output: 9 Constraints Constraints:
n == height.length 0 &amp;lt;= n &amp;lt;= 3 * 104 0 &amp;lt;= height[i] &amp;lt;= 105 Explanation On any point, to trap rain water we need to have walls adjacent to the current point with elevation more than the current elevation.</description></item></channel></rss>
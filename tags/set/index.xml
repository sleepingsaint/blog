<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>set on sleepingsaint</title><link>https://sleepingsaint.github.io/blog/tags/set/</link><description>Recent content in set on sleepingsaint</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 03 Aug 2021 13:33:12 +0530</lastBuildDate><atom:link href="https://sleepingsaint.github.io/blog/tags/set/index.xml" rel="self" type="application/rss+xml"/><item><title>Subsets 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/subsets-2/</link><pubDate>Tue, 03 Aug 2021 13:33:12 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/subsets-2/</guid><description>Question Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.
Examples Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] Input: nums = [0] Output: [[],[0]] Constraints 1 &amp;lt;= nums.length &amp;lt;= 10 -10 &amp;lt;= nums[i] &amp;lt;= 10 Explanation This problem is similar to generating all the subsets but catch is to avoid duplicate subsets.</description></item></channel></rss>
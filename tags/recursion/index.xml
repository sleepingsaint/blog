<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>recursion on sleepingsaint</title><link>https://sleepingsaint.github.io/blog/tags/recursion/</link><description>Recent content in recursion on sleepingsaint</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 02 Sep 2021 20:30:38 +0530</lastBuildDate><atom:link href="https://sleepingsaint.github.io/blog/tags/recursion/index.xml" rel="self" type="application/rss+xml"/><item><title>Unique Binary Search Trees 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/unique-binary-search-trees-2/</link><pubDate>Thu, 02 Sep 2021 20:30:38 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/unique-binary-search-trees-2/</guid><description>Question Given an integer n, return all the structurally unique BST&amp;rsquo;s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.
Examples Input: n = 3 Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
Input: n = 1 Output: [[1]]
Constraints 1 &amp;lt;= n &amp;lt;= 8 Explanation To construct any binary tree or binary search tree, we need root, left and right subtrees. So in the problem, if we consider one number in the given range as root, then elements to the left of it will be part of left substree and similarly for right subtree.</description></item><item><title>Verify Preorder Serialization of Binary Tree</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/verify-preorder-serialization-of-binary-tree/</link><pubDate>Thu, 26 Aug 2021 20:09:20 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/verify-preorder-serialization-of-binary-tree/</guid><description>Question One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node&amp;rsquo;s value. If it is a null node, we record using a sentinel value such as &amp;lsquo;#&amp;rsquo;.
For example, the above binary tree can be serialized to the string &amp;ldquo;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;rdquo;, where &amp;lsquo;#&amp;rsquo; represents a null node.
Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree.</description></item><item><title>Sudoku Solver</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/sudoku-solver/</link><pubDate>Sat, 21 Aug 2021 13:16:23 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/sudoku-solver/</guid><description>Question Write a program to solve a Sudoku puzzle by filling the empty cells.
A sudoku solution must satisfy all of the following rules:
Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The &amp;lsquo;.</description></item><item><title>Maximum Product of Splitted Binary Tree</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/maximum-product-of-splitted-binary-tree/</link><pubDate>Thu, 19 Aug 2021 20:02:40 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/maximum-product-of-splitted-binary-tree/</guid><description>Question Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.
Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.
Note that you need to maximize the answer before taking the mod and not after taking it.</description></item><item><title>Decode Ways</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/decode-ways/</link><pubDate>Wed, 18 Aug 2021 16:33:01 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/decode-ways/</guid><description>Question A message containing letters from A-Z can be encoded into numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; &amp;ldquo;1&amp;rdquo; &amp;lsquo;B&amp;rsquo; -&amp;gt; &amp;ldquo;2&amp;rdquo; &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; &amp;ldquo;26&amp;rdquo;
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;ldquo;11106&amp;rdquo; can be mapped into:
&amp;ldquo;AAJF&amp;rdquo; with the grouping (1 1 10 6) &amp;ldquo;KJF&amp;rdquo; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because &amp;ldquo;06&amp;rdquo; cannot be mapped into &amp;lsquo;F&amp;rsquo; since &amp;ldquo;6&amp;rdquo; is different from &amp;ldquo;06&amp;rdquo;.</description></item><item><title>Flip String to Monotone Increasing</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/flip-string-to-monotone-increasing/</link><pubDate>Wed, 11 Aug 2021 09:01:38 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/flip-string-to-monotone-increasing/</guid><description>Question A binary string is monotone increasing if it consists of some number of 0&amp;rsquo;s (possibly none), followed by some number of 1&amp;rsquo;s (also possibly none).
You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.
Return the minimum number of flips to make s monotone increasing.
Examples Input: s = &amp;ldquo;00110&amp;rdquo;
Output: 1
Explanation: We flip the last digit to get 00111.</description></item><item><title>Stone Game</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/stone-game/</link><pubDate>Thu, 05 Aug 2021 17:48:02 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/stone-game/</guid><description>Question Alex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].
The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties.
Alex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.</description></item><item><title>Pathsums 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/pathsums-2/</link><pubDate>Wed, 04 Aug 2021 13:06:06 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/pathsums-2/</guid><description>Question Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path&amp;rsquo;s sum equals targetSum.
A leaf is a node with no children.
Examples Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Input: root = [1,2,3], targetSum = 5 Output: [] Input: root = [1,2], targetSum = 0 Output: [] Constraints The number of nodes in the tree is in the range [0, 5000].</description></item><item><title>Subsets 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/subsets-2/</link><pubDate>Tue, 03 Aug 2021 13:33:12 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/subsets-2/</guid><description>Question Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.
Examples Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] Input: nums = [0] Output: [[],[0]] Constraints 1 &amp;lt;= nums.length &amp;lt;= 10 -10 &amp;lt;= nums[i] &amp;lt;= 10 Explanation This problem is similar to generating all the subsets but catch is to avoid duplicate subsets.</description></item></channel></rss>
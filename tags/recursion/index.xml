<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>recursion on sleepingsaint</title><link>https://sleepingsaint.github.io/blog/tags/recursion/</link><description>Recent content in recursion on sleepingsaint</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 18 Aug 2021 16:33:01 +0530</lastBuildDate><atom:link href="https://sleepingsaint.github.io/blog/tags/recursion/index.xml" rel="self" type="application/rss+xml"/><item><title>Decode Ways</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/decode-ways/</link><pubDate>Wed, 18 Aug 2021 16:33:01 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/decode-ways/</guid><description>Question A message containing letters from A-Z can be encoded into numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; &amp;ldquo;1&amp;rdquo; &amp;lsquo;B&amp;rsquo; -&amp;gt; &amp;ldquo;2&amp;rdquo; &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; &amp;ldquo;26&amp;rdquo;
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;ldquo;11106&amp;rdquo; can be mapped into:
&amp;ldquo;AAJF&amp;rdquo; with the grouping (1 1 10 6) &amp;ldquo;KJF&amp;rdquo; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because &amp;ldquo;06&amp;rdquo; cannot be mapped into &amp;lsquo;F&amp;rsquo; since &amp;ldquo;6&amp;rdquo; is different from &amp;ldquo;06&amp;rdquo;.</description></item><item><title>Flip String to Monotone Increasing</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/flip-string-to-monotone-increasing/</link><pubDate>Wed, 11 Aug 2021 09:01:38 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/flip-string-to-monotone-increasing/</guid><description>Question A binary string is monotone increasing if it consists of some number of 0&amp;rsquo;s (possibly none), followed by some number of 1&amp;rsquo;s (also possibly none).
You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.
Return the minimum number of flips to make s monotone increasing.
Examples Input: s = &amp;ldquo;00110&amp;rdquo;
Output: 1
Explanation: We flip the last digit to get 00111.</description></item><item><title>Stone Game</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/stone-game/</link><pubDate>Thu, 05 Aug 2021 17:48:02 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/stone-game/</guid><description>Question Alex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].
The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties.
Alex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.</description></item><item><title>Pathsums 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/pathsums-2/</link><pubDate>Wed, 04 Aug 2021 13:06:06 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/pathsums-2/</guid><description>Question Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path&amp;rsquo;s sum equals targetSum.
A leaf is a node with no children.
Examples Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Input: root = [1,2,3], targetSum = 5 Output: [] Input: root = [1,2], targetSum = 0 Output: [] Constraints The number of nodes in the tree is in the range [0, 5000].</description></item><item><title>Subsets 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/subsets-2/</link><pubDate>Tue, 03 Aug 2021 13:33:12 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/subsets-2/</guid><description>Question Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.
Examples Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] Input: nums = [0] Output: [[],[0]] Constraints 1 &amp;lt;= nums.length &amp;lt;= 10 -10 &amp;lt;= nums[i] &amp;lt;= 10 Explanation This problem is similar to generating all the subsets but catch is to avoid duplicate subsets.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Series on sleepingsaint</title><link>https://sleepingsaint.github.io/blog/series/</link><description>Recent content in Series on sleepingsaint</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 08 Aug 2021 16:26:38 +0530</lastBuildDate><atom:link href="https://sleepingsaint.github.io/blog/series/index.xml" rel="self" type="application/rss+xml"/><item><title>Rank Transform of Matrix</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/rank-transform-of-matrix/</link><pubDate>Sun, 08 Aug 2021 16:26:38 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/rank-transform-of-matrix/</guid><description>Question Given an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col].
The rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:
The rank is an integer starting from 1.
If two elements p and q are in the same row or column, then:
If p &amp;lt; q then rank(p) &amp;lt; rank(q) If p == q then rank(p) == rank(q) If p &amp;gt; q then rank(p) &amp;gt; rank(q) The rank should be as small as possible.</description></item><item><title>Palindrome Partitioning 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/palindrome-partitioning-2/</link><pubDate>Sat, 07 Aug 2021 18:57:45 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/palindrome-partitioning-2/</guid><description>Question Given a string s, partition s such that every substring of the partition is a palindrome.
Return the minimum cuts needed for a palindrome partitioning of s.
Examples Input: s = &amp;ldquo;aab&amp;rdquo;
Output: 1
Explanation: The palindrome partitioning [&amp;ldquo;aa&amp;rdquo;,&amp;ldquo;b&amp;rdquo;] could be produced using 1 cut.
Input: s = &amp;ldquo;a&amp;rdquo;
Output: 0
Input: s = "ab" Output: 1
Constraints 1 &amp;lt;= s.length &amp;lt;= 2000 s consists of lower-case English letters only.</description></item><item><title>N Array Level Order Traversal</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/n-array-level-order-traversal/</link><pubDate>Fri, 06 Aug 2021 12:59:53 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/n-array-level-order-traversal/</guid><description>Question Given an n-ary tree, return the level order traversal of its nodes' values.
Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).
Examples Input: root = [1,null,3,2,4,null,5,6] Output: [[1],[3,2,4],[5,6]] Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] Constraints The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 104] Explanation Level Order Traversal As the name suggests we travese the tree level wise, first the root, then all the children of the root, then children of children of the root and so on.</description></item><item><title>Stone Game</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/stone-game/</link><pubDate>Thu, 05 Aug 2021 17:48:02 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/stone-game/</guid><description>Question Alex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].
The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties.
Alex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.</description></item><item><title>Pathsums 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/pathsums-2/</link><pubDate>Wed, 04 Aug 2021 13:06:06 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/pathsums-2/</guid><description>Question Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path&amp;rsquo;s sum equals targetSum.
A leaf is a node with no children.
Examples Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Input: root = [1,2,3], targetSum = 5 Output: [] Input: root = [1,2], targetSum = 0 Output: [] Constraints The number of nodes in the tree is in the range [0, 5000].</description></item><item><title>Subsets 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/subsets-2/</link><pubDate>Tue, 03 Aug 2021 13:33:12 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/subsets-2/</guid><description>Question Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.
Examples Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] Input: nums = [0] Output: [[],[0]] Constraints 1 &amp;lt;= nums.length &amp;lt;= 10 -10 &amp;lt;= nums[i] &amp;lt;= 10 Explanation This problem is similar to generating all the subsets but catch is to avoid duplicate subsets.</description></item><item><title>Two Sum</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/two-sum/</link><pubDate>Mon, 02 Aug 2021 12:51:20 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/two-sum/</guid><description>Question Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Examples Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1].</description></item><item><title>Making a Large Island</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/making-a-large-island/</link><pubDate>Sun, 01 Aug 2021 15:39:51 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/making-a-large-island/</guid><description>Question You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1. Return the size of the largest island in grid after applying this operation.
An island is a 4-directionally connected group of 1s.
Examples Input: grid = [[1,0],[0,1]]
Output: 3
Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.</description></item><item><title>Trapping Rain Water</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/trapping-rain-water/</link><pubDate>Sat, 31 Jul 2021 13:26:43 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/trapping-rain-water/</guid><description>Question Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
Example Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Input: height = [4,2,0,3,2,5] Output: 9 Constraints Constraints:
n == height.length 0 &amp;lt;= n &amp;lt;= 3 * 104 0 &amp;lt;= height[i] &amp;lt;= 105 Explanation On any point, to trap rain water we need to have walls adjacent to the current point with elevation more than the current elevation.</description></item><item><title>01 Matrix</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/01-matrix/</link><pubDate>Sat, 31 Jul 2021 13:00:13 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/01-matrix/</guid><description>Question Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.
The distance between two adjacent cells is 1.
Examples Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]
Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]
Constraints m == mat.length n == mat[i].length 1 &amp;lt;= m, n &amp;lt;= 104 1 &amp;lt;= m * n &amp;lt;= 104 mat[i][j] is either 0 or 1. There is at least one 0 in mat.</description></item><item><title>Map Sum Pairs</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/map-sum-pairs/</link><pubDate>Fri, 30 Jul 2021 21:36:35 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/map-sum-pairs/</guid><description>Map Sum Pairs Question Implement the MapSum class:
MapSum() Initializes the MapSum object. void insert(String key, int val) Inserts the key-val pair into the map. If the key already existed, the original key-value pair will be overridden to the new one. int sum(string prefix) Returns the sum of all the pairs' value whose key starts with the prefix. Constraints Constraints:</description></item></channel></rss>
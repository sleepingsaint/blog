<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Series on sleepingsaint</title><link>https://sleepingsaint.github.io/blog/series/</link><description>Recent content in Series on sleepingsaint</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 30 Aug 2021 19:19:25 +0530</lastBuildDate><atom:link href="https://sleepingsaint.github.io/blog/series/index.xml" rel="self" type="application/rss+xml"/><item><title>Range Addition 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/range-addition-2/</link><pubDate>Mon, 30 Aug 2021 19:19:25 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/range-addition-2/</guid><description>Question You are given an m x n matrix M initialized with all 0&amp;rsquo;s and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 &amp;lt;= x &amp;lt; ai and 0 &amp;lt;= y &amp;lt; bi.
Count and return the number of maximum integers in the matrix after performing all the operations.
Examples Input: m = 3, n = 3, ops = [[2,2],[3,3]] Output: 4 Explanation: The maximum integer in M is 2, and there are four of it in M.</description></item><item><title>Patching Array</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/patching-array/</link><pubDate>Sun, 29 Aug 2021 23:10:49 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/patching-array/</guid><description>Question Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.
Return the minimum number of patches required.
Examples Input: nums = [1,3], n = 6 Output: 1 Explanation: Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.</description></item><item><title>Longest Uncommon Subsequence</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/longest-uncommon-subsequence/</link><pubDate>Sun, 29 Aug 2021 01:45:42 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/longest-uncommon-subsequence/</guid><description>Question Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1.
An uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others.
A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.</description></item><item><title>Maximum Profit in Job Scheduling</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/maximum-profit-in-job-scheduling/</link><pubDate>Sun, 29 Aug 2021 01:09:02 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/maximum-profit-in-job-scheduling/</guid><description>Question We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].
You&amp;rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.
If you choose a job that ends at time X you will be able to start another job that starts at time X.</description></item><item><title>Verify Preorder Serialization of Binary Tree</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/verify-preorder-serialization-of-binary-tree/</link><pubDate>Thu, 26 Aug 2021 20:09:20 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/verify-preorder-serialization-of-binary-tree/</guid><description>Question One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node&amp;rsquo;s value. If it is a null node, we record using a sentinel value such as &amp;lsquo;#&amp;rsquo;.
For example, the above binary tree can be serialized to the string &amp;ldquo;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;rdquo;, where &amp;lsquo;#&amp;rsquo; represents a null node.
Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree.</description></item><item><title>Sum of Square Numbers</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/sum-of-square-numbers/</link><pubDate>Wed, 25 Aug 2021 14:49:17 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/sum-of-square-numbers/</guid><description>Question Given a non-negative integer c, decide whether there&amp;rsquo;re two integers a and b such that a^2 + b^2 = c.
Examples Input: c = 5 Output: true Explanation: 1 * 1 + 2 * 2 = 5
Input: c = 3 Output: false
Input: c = 4 Output: true
Constraints 0 &amp;lt;= c &amp;lt;= 231 - 1 Explanation The maximum value for a, b is square root of c, and the other value will be 0.</description></item><item><title>Rectangle Area 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/rectangle-area-2/</link><pubDate>Tue, 24 Aug 2021 14:50:29 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/rectangle-area-2/</guid><description>Question We are given a list of (axis-aligned) rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] , where (xi1, yi1) are the coordinates of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-right corner of the ith rectangle.
Find the total area covered by all rectangles in the plane. Since the answer may be too large, return it modulo 10^9 + 7.
Examples Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]] Output: 6 Explanation: As illustrated in the picture.</description></item><item><title>Complex Number Multiplication</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/complex-number-multiplication/</link><pubDate>Tue, 24 Aug 2021 13:58:03 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/complex-number-multiplication/</guid><description>Question A complex number can be represented as a string on the form &amp;ldquo;real+imaginaryi&amp;rdquo; where:
real is the real part and is an integer in the range [-100, 100]. imaginary is the imaginary part and is an integer in the range [-100, 100]. i^2 == -1. Given two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications.
Examples Input: num1 = &amp;ldquo;1+1i&amp;rdquo;, num2 = &amp;ldquo;1+1i&amp;rdquo;</description></item><item><title>Two Sum IV Input Is a Bst</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/two-sum-iv-input-is-a-bst/</link><pubDate>Mon, 23 Aug 2021 15:35:01 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/two-sum-iv-input-is-a-bst/</guid><description>Question Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.
Examples Input: root = [5,3,6,2,4,null,7], k = 9 Output: true
Input: root = [5,3,6,2,4,null,7], k = 28
Output: false
Input: root = [2,1,3], k = 4
Output: true
Input: root = [2,1,3], k = 1
Output: false</description></item><item><title>Sudoku Solver</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/sudoku-solver/</link><pubDate>Sat, 21 Aug 2021 13:16:23 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/sudoku-solver/</guid><description>Question Write a program to solve a Sudoku puzzle by filling the empty cells.
A sudoku solution must satisfy all of the following rules:
Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The &amp;lsquo;.</description></item><item><title>Valid Sudoku</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/valid-sudoku/</link><pubDate>Fri, 20 Aug 2021 13:39:26 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/valid-sudoku/</guid><description>Question Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable.</description></item><item><title>Maximum Product of Splitted Binary Tree</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/maximum-product-of-splitted-binary-tree/</link><pubDate>Thu, 19 Aug 2021 20:02:40 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/maximum-product-of-splitted-binary-tree/</guid><description>Question Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.
Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.
Note that you need to maximize the answer before taking the mod and not after taking it.</description></item><item><title>Decode Ways</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/decode-ways/</link><pubDate>Wed, 18 Aug 2021 16:33:01 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/decode-ways/</guid><description>Question A message containing letters from A-Z can be encoded into numbers using the following mapping:
&amp;lsquo;A&amp;rsquo; -&amp;gt; &amp;ldquo;1&amp;rdquo; &amp;lsquo;B&amp;rsquo; -&amp;gt; &amp;ldquo;2&amp;rdquo; &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; &amp;ldquo;26&amp;rdquo;
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;ldquo;11106&amp;rdquo; can be mapped into:
&amp;ldquo;AAJF&amp;rdquo; with the grouping (1 1 10 6) &amp;ldquo;KJF&amp;rdquo; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because &amp;ldquo;06&amp;rdquo; cannot be mapped into &amp;lsquo;F&amp;rsquo; since &amp;ldquo;6&amp;rdquo; is different from &amp;ldquo;06&amp;rdquo;.</description></item><item><title>Count Good Nodes in Binary Tree</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/count-good-nodes-in-binary-tree/</link><pubDate>Tue, 17 Aug 2021 12:58:18 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/count-good-nodes-in-binary-tree/</guid><description>Question Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.
Return the number of good nodes in the binary tree.
Examples Input: root = [3,1,4,3,null,1,5] Output: 4 Explanation: Nodes in blue are good. Root Node (3) is always a good node.
Node 4 -&amp;gt; (3,4) is the maximum value in the path starting from the root.</description></item><item><title>Range Sum Query Immutable</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/range-sum-query-immutable/</link><pubDate>Mon, 16 Aug 2021 13:24:12 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/range-sum-query-immutable/</guid><description>Question Given an integer array nums, handle multiple queries of the following type:
Calculate the sum of the elements of nums between indices left and right inclusive where left &amp;lt;= right.
Implement the NumArray class:
NumArray(int[] nums) Initializes the object with the integer array nums. int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + &amp;hellip; + nums[right]).</description></item><item><title>Minimum Window Substring</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/minimum-window-substring/</link><pubDate>Mon, 16 Aug 2021 13:23:57 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/minimum-window-substring/</guid><description>Question Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &amp;ldquo;&amp;rdquo;.
The testcases will be generated such that the answer is unique.
A substring is a contiguous sequence of characters within the string.
Examples Input: s = &amp;ldquo;ADOBECODEBANC&amp;rdquo;, t = &amp;ldquo;ABC&amp;rdquo;</description></item><item><title>Remove Boxes</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/remove-boxes/</link><pubDate>Sat, 14 Aug 2021 22:30:00 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/remove-boxes/</guid><description>Question You are given several boxes with different colors represented by different positive numbers.
You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k &amp;gt;= 1), remove them and get k * k points.
Return the maximum points you can get.
Examples Input: boxes = [1,3,2,2,2,3,4,3,1]
Output: 23</description></item><item><title>Set Matrix Zeroes</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/set-matrix-zeroes/</link><pubDate>Fri, 13 Aug 2021 13:36:46 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/set-matrix-zeroes/</guid><description>Question Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s, and return the matrix.
You must do it in place.
Examples Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[1,0,1],[0,0,0],[1,0,1]]
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
Constraints m == matrix.length n == matrix[0].length 1 &amp;lt;= m, n &amp;lt;= 200 -2^31 &amp;lt;= matrix[i][j] &amp;lt;= 2^31 - 1 Explanation One approach for this problem is, we maintain two hashmap to store which row and column should be made 0.</description></item><item><title>Group Anagrams</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/group-anagrams/</link><pubDate>Thu, 12 Aug 2021 14:09:06 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/group-anagrams/</guid><description>Question Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Examples Input: strs = [&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;tea&amp;rdquo;,&amp;ldquo;tan&amp;rdquo;,&amp;ldquo;ate&amp;rdquo;,&amp;ldquo;nat&amp;rdquo;,&amp;ldquo;bat&amp;rdquo;]
Output: [[&amp;ldquo;bat&amp;rdquo;],[&amp;ldquo;nat&amp;rdquo;,&amp;ldquo;tan&amp;rdquo;],[&amp;ldquo;ate&amp;rdquo;,&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;tea&amp;rdquo;]]
Input: strs = [&amp;quot;&amp;quot;]
Output: [[&amp;quot;&amp;quot;]]
Input: strs = [&amp;ldquo;a&amp;rdquo;]
Output: [[&amp;ldquo;a&amp;rdquo;]]
Constraints 1 &amp;lt;= strs.length &amp;lt;= 104 0 &amp;lt;= strs[i].</description></item><item><title>Array of Doubled Pairs</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/array-of-doubled-pairs/</link><pubDate>Wed, 11 Aug 2021 19:53:05 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/array-of-doubled-pairs/</guid><description>Question Given an array of integers arr of even length, return true if and only if it is possible to reorder it such that arr[2 * i + 1] = 2 * arr[2 * i] for every 0 &amp;lt;= i &amp;lt; len(arr) / 2.
Examples Input: arr = [3,1,3,6]
Output: false
Input: arr = [2,1,2,6]
Output: false
Input: arr = [4,-2,2,-4]
Output: true
Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].</description></item><item><title>Flip String to Monotone Increasing</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/flip-string-to-monotone-increasing/</link><pubDate>Wed, 11 Aug 2021 09:01:38 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/flip-string-to-monotone-increasing/</guid><description>Question A binary string is monotone increasing if it consists of some number of 0&amp;rsquo;s (possibly none), followed by some number of 1&amp;rsquo;s (also possibly none).
You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.
Return the minimum number of flips to make s monotone increasing.
Examples Input: s = &amp;ldquo;00110&amp;rdquo;
Output: 1
Explanation: We flip the last digit to get 00111.</description></item><item><title>Add Strings</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/add-strings/</link><pubDate>Mon, 09 Aug 2021 14:48:21 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/add-strings/</guid><description>Question Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.
You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.
Examples Input: num1 = &amp;ldquo;11&amp;rdquo;, num2 = &amp;ldquo;123&amp;rdquo;
Output: &amp;ldquo;134&amp;rdquo;
Input: num1 = &amp;ldquo;456&amp;rdquo;, num2 = &amp;ldquo;77&amp;rdquo;
Output: &amp;ldquo;533&amp;rdquo;
Input: num1 = &amp;ldquo;0&amp;rdquo;, num2 = &amp;ldquo;0&amp;rdquo;</description></item><item><title>Rank Transform of Matrix</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/rank-transform-of-matrix/</link><pubDate>Sun, 08 Aug 2021 16:26:38 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/rank-transform-of-matrix/</guid><description>Question Given an m x n matrix, return a new matrix answer where answer[row][col] is the rank of matrix[row][col].
The rank is an integer that represents how large an element is compared to other elements. It is calculated using the following rules:
The rank is an integer starting from 1.
If two elements p and q are in the same row or column, then:
If p &amp;lt; q then rank(p) &amp;lt; rank(q) If p == q then rank(p) == rank(q) If p &amp;gt; q then rank(p) &amp;gt; rank(q) The rank should be as small as possible.</description></item><item><title>Palindrome Partitioning 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/palindrome-partitioning-2/</link><pubDate>Sat, 07 Aug 2021 18:57:45 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/palindrome-partitioning-2/</guid><description>Question Given a string s, partition s such that every substring of the partition is a palindrome.
Return the minimum cuts needed for a palindrome partitioning of s.
Examples Input: s = &amp;ldquo;aab&amp;rdquo;
Output: 1
Explanation: The palindrome partitioning [&amp;ldquo;aa&amp;rdquo;,&amp;ldquo;b&amp;rdquo;] could be produced using 1 cut.
Input: s = &amp;ldquo;a&amp;rdquo;
Output: 0
Input: s = "ab" Output: 1
Constraints 1 &amp;lt;= s.length &amp;lt;= 2000 s consists of lower-case English letters only.</description></item><item><title>N Array Level Order Traversal</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/n-array-level-order-traversal/</link><pubDate>Fri, 06 Aug 2021 12:59:53 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/n-array-level-order-traversal/</guid><description>Question Given an n-ary tree, return the level order traversal of its nodes' values.
Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).
Examples Input: root = [1,null,3,2,4,null,5,6] Output: [[1],[3,2,4],[5,6]] Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] Constraints The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 104] Explanation Level Order Traversal As the name suggests we travese the tree level wise, first the root, then all the children of the root, then children of children of the root and so on.</description></item><item><title>Stone Game</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/stone-game/</link><pubDate>Thu, 05 Aug 2021 17:48:02 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/stone-game/</guid><description>Question Alex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].
The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties.
Alex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.</description></item><item><title>Pathsums 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/pathsums-2/</link><pubDate>Wed, 04 Aug 2021 13:06:06 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/pathsums-2/</guid><description>Question Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path&amp;rsquo;s sum equals targetSum.
A leaf is a node with no children.
Examples Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Input: root = [1,2,3], targetSum = 5 Output: [] Input: root = [1,2], targetSum = 0 Output: [] Constraints The number of nodes in the tree is in the range [0, 5000].</description></item><item><title>Subsets 2</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/subsets-2/</link><pubDate>Tue, 03 Aug 2021 13:33:12 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/subsets-2/</guid><description>Question Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.
Examples Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] Input: nums = [0] Output: [[],[0]] Constraints 1 &amp;lt;= nums.length &amp;lt;= 10 -10 &amp;lt;= nums[i] &amp;lt;= 10 Explanation This problem is similar to generating all the subsets but catch is to avoid duplicate subsets.</description></item><item><title>Two Sum</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/two-sum/</link><pubDate>Mon, 02 Aug 2021 12:51:20 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/two-sum/</guid><description>Question Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Examples Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1].</description></item><item><title>Making a Large Island</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/making-a-large-island/</link><pubDate>Sun, 01 Aug 2021 15:39:51 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/making-a-large-island/</guid><description>Question You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1. Return the size of the largest island in grid after applying this operation.
An island is a 4-directionally connected group of 1s.
Examples Input: grid = [[1,0],[0,1]]
Output: 3
Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.</description></item><item><title>Trapping Rain Water</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/trapping-rain-water/</link><pubDate>Sat, 31 Jul 2021 13:26:43 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/trapping-rain-water/</guid><description>Question Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
Example Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Input: height = [4,2,0,3,2,5] Output: 9 Constraints Constraints:
n == height.length 0 &amp;lt;= n &amp;lt;= 3 * 104 0 &amp;lt;= height[i] &amp;lt;= 105 Explanation On any point, to trap rain water we need to have walls adjacent to the current point with elevation more than the current elevation.</description></item><item><title>01 Matrix</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/01-matrix/</link><pubDate>Sat, 31 Jul 2021 13:00:13 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/01-matrix/</guid><description>Question Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.
The distance between two adjacent cells is 1.
Examples Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]
Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]
Constraints m == mat.length n == mat[i].length 1 &amp;lt;= m, n &amp;lt;= 104 1 &amp;lt;= m * n &amp;lt;= 104 mat[i][j] is either 0 or 1. There is at least one 0 in mat.</description></item><item><title>Map Sum Pairs</title><link>https://sleepingsaint.github.io/blog/series/leetcode-daily/map-sum-pairs/</link><pubDate>Fri, 30 Jul 2021 21:36:35 +0530</pubDate><guid>https://sleepingsaint.github.io/blog/series/leetcode-daily/map-sum-pairs/</guid><description>Map Sum Pairs Question Implement the MapSum class:
MapSum() Initializes the MapSum object. void insert(String key, int val) Inserts the key-val pair into the map. If the key already existed, the original key-value pair will be overridden to the new one. int sum(string prefix) Returns the sum of all the pairs' value whose key starts with the prefix. Constraints Constraints:</description></item></channel></rss>
<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>sleepingsaint | Subsets 2</title>
<link rel=stylesheet href=https://sleepingsaint.github.io/blog/css/index.css>
</head>
<body>
<div class=navbar-container>
<h1>sleepingsaint</h1>
<div>
<a href=https://sleepingsaint.github.io/blog/>Home</a>
<a href=https://sleepingsaint.github.io/blog/posts/>Posts</a>
<a href=https://sleepingsaint.github.io/blog/series/>Series</a>
<a href=https://sleepingsaint.github.io/blog/tags/>Tags</a>
</div>
</div>
<div class=post-container>
<h2 id=question>Question</h2>
<p>Given an integer array nums that may contain duplicates, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.</p>
<h2 id=examples>Examples</h2>
<p>Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]</p>
<p>Input: nums = [0]
Output: [[],[0]]</p>
<h2 id=constraints>Constraints</h2>
<ul>
<li>1 &lt;= nums.length &lt;= 10</li>
<li>-10 &lt;= nums[i] &lt;= 10</li>
</ul>
<h2 id=explanation>Explanation</h2>
<p>This problem is similar to generating all the subsets but catch is to avoid duplicate subsets. So to check if a subset is already added to the answer, we can use a <strong>hasmap or set</strong>. We create a string representation of every subset and check if it already exists. If it doesn&rsquo;t, we add the string representation of subset to hashmap or set and the subset to the answer.</p>
<h2 id=code>Code</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
	<span style=color:#75715e>// In this code I used set to track the added the subsets
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>typedef</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> vvi;

	<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
		<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
			vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> subsetsWithDup(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
				vvi ans;
				set<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> sets;
				sort(nums.begin(), nums.end());
				recursion(ans, sets, nums, <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;&#34;</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>{});
				<span style=color:#66d9ef>return</span> ans;
			}

			<span style=color:#75715e>// recursive function to compute the subsets
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>recursion</span>(vvi <span style=color:#f92672>&amp;</span>ans, set<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>sets, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>nums, <span style=color:#66d9ef>int</span> i, string curr, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vec){
				<span style=color:#66d9ef>if</span>(i <span style=color:#f92672>==</span> nums.size()){
					<span style=color:#75715e>// checking if the sets already exists
</span><span style=color:#75715e></span>					<span style=color:#66d9ef>if</span>(sets.find(curr) <span style=color:#f92672>==</span> sets.end()){

						<span style=color:#75715e>// if subset doesn&#39;t exists
</span><span style=color:#75715e></span>						<span style=color:#75715e>// we add the subset to the ans
</span><span style=color:#75715e></span>						<span style=color:#75715e>// and string representation to set
</span><span style=color:#75715e></span>						sets.insert(curr);
						ans.push_back(vec);
					}
					<span style=color:#66d9ef>return</span>;
				}

				recursion(ans, sets, nums, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, curr, vec);
				vec.push_back(nums[i]);
				recursion(ans, sets, nums, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, curr <span style=color:#f92672>+</span> to_string(nums[i]), vec);
			}
		};

</code></pre></div><h2 id=space-and-time-complexity>Space and Time Complexity</h2>
<p>Time Complexity: O(2^n) - n is number of elements in nums array
Space Complexity: O(2^n) - In the worst case we store all the subsets string representations.</p>
</div>
</body>
</html>
<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>sleepingsaint | Minimum Window Substring</title>
<link rel=stylesheet href=https://sleepingsaint.github.io/blog/css/index.css>
</head>
<body>
<div class=navbar-container>
<h1>sleepingsaint</h1>
<div>
<a href=https://sleepingsaint.github.io/blog/>Home</a>
<a href=https://sleepingsaint.github.io/blog/posts/>Posts</a>
<a href=https://sleepingsaint.github.io/blog/series/>Series</a>
<a href=https://sleepingsaint.github.io/blog/tags/>Tags</a>
</div>
</div>
<div class=post-container>
<h2 id=question>Question</h2>
<p>Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &ldquo;&rdquo;.</p>
<p>The testcases will be generated such that the answer is unique.</p>
<p>A substring is a contiguous sequence of characters within the string.</p>
<h2 id=examples>Examples</h2>
<p>Input: s = &ldquo;ADOBECODEBANC&rdquo;, t = &ldquo;ABC&rdquo;</p>
<p>Output: &ldquo;BANC&rdquo;</p>
<p>Explanation: The minimum window substring &ldquo;BANC&rdquo; includes &lsquo;A&rsquo;, &lsquo;B&rsquo;, and &lsquo;C&rsquo; from string t.</p>
<hr>
<p>Input: s = &ldquo;a&rdquo;, t = &ldquo;a&rdquo;</p>
<p>Output: &ldquo;a&rdquo;</p>
<p>Explanation: The entire string s is the minimum window.</p>
<hr>
<p>Input: s = &ldquo;a&rdquo;, t = &ldquo;aa&rdquo;</p>
<p>Output: ""</p>
<p>Explanation: Both &lsquo;a&rsquo;s from t must be included in the window. Since the largest window of s only has one &lsquo;a&rsquo;, return empty string.</p>
<h2 id=constraints>Constraints</h2>
<ul>
<li>m == s.length</li>
<li>n == t.length</li>
<li>1 &lt;= m, n &lt;= 105</li>
<li>s and t consist of uppercase and lowercase English letters.</li>
</ul>
<h2 id=explanation>Explanation</h2>
<p>A brute approach would be to get all the substrings and check if it contains all the characters in t and pick the minimum length substring. A much better approach is to use the <strong>sliding window</strong> technique. As the name indicates we create a window and check if the requirements are met or not, if not met we move the window, if met we try to contract the window. The below shows how it looks while implementing.</p>
<div style=display:flex;justify-content:center>
<p><img src=https://www.researchgate.net/profile/Ali-Raza-76/publication/325158306/figure/fig5/AS:681968115134465@1539605277480/Sliding-window-technique.ppm alt="Sliding Window Image"></p>
</div>
<p>In this problem our requirement is to have all the characters of the string t.</p>
<p>We start with two pointers initially at the start of the string s, then we move the end pointer untill we met the requirement and when we met the requirement we minimise the window. To check if we met the requirement, we maintain a variable to track the count of the characters in the current window and an <strong>hashmap</strong> to check if the current character is in the string t and another <strong>hashmap</strong> to keep track of all characters in the current window.</p>
<p>The variable we maintaing is counting only the characters which are both in the current window and in the string t, where as the window hashmap keep track of all the characters even though they don&rsquo;t exist in the string t.</p>
<h2 id=code>Code</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
	<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
	<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
		string minWindow(string s, string t) {
			<span style=color:#75715e>// if one of the strings is empty then the answer is also empty string
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span>(s.length() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> t.length() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
				<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>;
			
			<span style=color:#75715e>// hashmap to store the characters of string t
</span><span style=color:#75715e></span>			unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> tcount;
			<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>char</span> c: t)
				tcount[c]<span style=color:#f92672>++</span>;
			
			<span style=color:#75715e>// variables to return the answer / substring
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>int</span> minLength <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, start <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
			
			<span style=color:#75715e>// start and end pointers of the window
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
			
			<span style=color:#75715e>// hashmap to keep track the characters in window
</span><span style=color:#75715e></span>			unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> wcount;

			<span style=color:#75715e>// this keep track of the characters visited
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
			
			<span style=color:#66d9ef>while</span>(j <span style=color:#f92672>&lt;</span> s.length()){
				<span style=color:#75715e>// increase the count of the character in the current window
</span><span style=color:#75715e></span>				wcount[s[j]]<span style=color:#f92672>++</span>;
				
				<span style=color:#75715e>// if we got all occurences of a character in the window we increment the count
</span><span style=color:#75715e></span>				<span style=color:#66d9ef>if</span>(tcount.find(s[j]) <span style=color:#f92672>!=</span> tcount.end() <span style=color:#f92672>&amp;&amp;</span> tcount[s[j]] <span style=color:#f92672>==</span> wcount[s[j]])
					count<span style=color:#f92672>++</span>;
				
				<span style=color:#75715e>// if we found all the characters in the current window
</span><span style=color:#75715e></span>				<span style=color:#75715e>// we try to minimize the window
</span><span style=color:#75715e></span>				<span style=color:#66d9ef>while</span>(count <span style=color:#f92672>==</span> tcount.size() <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>&lt;=</span> j){
					
					<span style=color:#75715e>// update the answer
</span><span style=color:#75715e></span>					<span style=color:#66d9ef>if</span>(minLength <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> minLength <span style=color:#f92672>&gt;</span> j <span style=color:#f92672>-</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>){
						minLength <span style=color:#f92672>=</span> j <span style=color:#f92672>-</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
						start <span style=color:#f92672>=</span> i;
					}
					
					wcount[s[i]]<span style=color:#f92672>--</span>;
					
					<span style=color:#75715e>// if we are short of some characters we decrement the count variable 
</span><span style=color:#75715e></span>					<span style=color:#75715e>// indicating that the window is not valid anymore
</span><span style=color:#75715e></span>					<span style=color:#66d9ef>if</span>(tcount.find(s[i]) <span style=color:#f92672>!=</span> tcount.end() <span style=color:#f92672>&amp;&amp;</span> wcount[s[i]] <span style=color:#f92672>&lt;</span> tcount[s[i]])
						count<span style=color:#f92672>--</span>;
					
					i<span style=color:#f92672>++</span>;
				}
				
				j<span style=color:#f92672>++</span>;
			}

			<span style=color:#75715e>// if we found the answer we return the substring else empty string
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> minLength <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>:</span> s.substr(start, minLength);
		}
	};

</code></pre></div><h2 id=space-and-time-complexity>Space and Time Complexity</h2>
<p>N - length of string t, M - length of string s</p>
<ul>
<li>Space Complexity: O(N + M) - for storing the characters in the hashmap</li>
<li>Time Complexity: O(2xM) - atmost we encounter each variable twice so the time complexity is 2xM</li>
</ul>
</div>
</body>
</html>
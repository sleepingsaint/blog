<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>sleepingsaint | Count Good Nodes in Binary Tree</title>
<link rel=stylesheet href=https://sleepingsaint.github.io/blog/css/index.css>
</head>
<body>
<div class=navbar-container>
<h1>sleepingsaint</h1>
<div>
<a href=https://sleepingsaint.github.io/blog/>Home</a>
<a href=https://sleepingsaint.github.io/blog/posts/>Posts</a>
<a href=https://sleepingsaint.github.io/blog/series/>Series</a>
<a href=https://sleepingsaint.github.io/blog/tags/>Tags</a>
</div>
</div>
<div class=post-container>
<h2 id=question>Question</h2>
<p>Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.</p>
<p>Return the number of good nodes in the binary tree.</p>
<h2 id=examples>Examples</h2>
<p>Input: root = [3,1,4,3,null,1,5] <br>
Output: 4 <br>
Explanation: Nodes in blue are good. <br>
Root Node (3) is always a good node.<br>
Node 4 -> (3,4) is the maximum value in the path starting from the root.<br>
Node 5 -> (3,4,5) is the maximum value in the path<br>
Node 3 -> (3,1,3) is the maximum value in the path.</p>
<hr>
<p>Input: root = [3,3,null,4,2] <br>
Output: 3<br>
Explanation: Node 2 -> (3, 3, 2) is not good, because &ldquo;3&rdquo; is higher than it.</p>
<hr>
<p>Input: root = [1]<br>
Output: 1<br>
Explanation: Root is considered as good.</p>
<h2 id=constraints>Constraints</h2>
<ul>
<li>The number of nodes in the binary tree is in the range [1, 10^5].</li>
<li>Each node&rsquo;s value is between [-10^4, 10^4]</li>
</ul>
<h2 id=explanation>Explanation</h2>
<p>To solve this problem at any node, if we know the maximum value node in the path from root to the current node we can easily calculate the answer by comparing the current maximum value and current node value. After the comparision we try to update the maximum value and find the number of nodes in the left and right subtrees. This can be easily implemented using <strong>recursion and dfs</strong>.</p>
<h2 id=code>Code</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
	<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
	<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
		<span style=color:#66d9ef>int</span> goodNodes(TreeNode<span style=color:#f92672>*</span> root) {
			<span style=color:#75715e>// if no root exists then good nodes are also 0
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>root) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;

			<span style=color:#75715e>// calling the dfs function to calculate the good nodes in the tree
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>dfs</span>(root, root<span style=color:#f92672>-&gt;</span>val);
		}
		
		<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dfs</span>(TreeNode<span style=color:#f92672>*</span> root, <span style=color:#66d9ef>int</span> maxVal){
			<span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>root) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
			<span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

			<span style=color:#75715e>// if current node value is greater than or equal
</span><span style=color:#75715e></span>			<span style=color:#75715e>// to current max value we increase the count
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span>(root<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>&gt;=</span> maxVal)
				count<span style=color:#f92672>++</span>;
			
			<span style=color:#75715e>// updating the maxVal if current val is greater than curr max value
</span><span style=color:#75715e></span>			maxVal <span style=color:#f92672>=</span> max(maxVal, root<span style=color:#f92672>-&gt;</span>val);

			<span style=color:#75715e>// calculating the good nodes in left and right subtrees.
</span><span style=color:#75715e></span>			count <span style=color:#f92672>+=</span> dfs(root<span style=color:#f92672>-&gt;</span>left, maxVal);
			count <span style=color:#f92672>+=</span> dfs(root<span style=color:#f92672>-&gt;</span>right, maxVal);

			<span style=color:#66d9ef>return</span> count;
		}
	};

</code></pre></div><h2 id=space-and-time-complexity>Space and Time Complexity</h2>
<p>N - number of nodes in the tree</p>
<ul>
<li>Space Complexity - O(N) - in the worst case where tree is skewed so to store all the recursion stack we need O(N) space</li>
<li>Time Complexity - O(N) - we are visiting every node only once</li>
</ul>
</div>
</body>
</html>
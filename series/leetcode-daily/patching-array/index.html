<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>sleepingsaint | Patching Array</title>
<link rel=stylesheet href=https://sleepingsaint.github.io/blog/css/index.css>
</head>
<body>
<div class=navbar-container>
<h1>sleepingsaint</h1>
<div>
<a href=https://sleepingsaint.github.io/blog/>Home</a>
<a href=https://sleepingsaint.github.io/blog/posts/>Posts</a>
<a href=https://sleepingsaint.github.io/blog/series/>Series</a>
<a href=https://sleepingsaint.github.io/blog/tags/>Tags</a>
</div>
</div>
<div class=post-container>
<h2 id=question>Question</h2>
<p>Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.</p>
<p>Return the minimum number of patches required.</p>
<h2 id=examples>Examples</h2>
<p>Input: nums = [1,3], n = 6 <br>
Output: 1 <br>
Explanation:
Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.
Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].</p>
<p>So we only need 1 patch.</p>
<hr>
<p>Input: nums = [1,5,10], n = 20 <br>
Output: 2 <br>
Explanation: The two patches can be [2, 4].</p>
<hr>
<p>Input: nums = [1,2,2], n = 5 <br>
Output: 0</p>
<h2 id=constraints>Constraints</h2>
<ul>
<li>1 &lt;= nums.length &lt;= 1000</li>
<li>1 &lt;= nums[i] &lt;= 10^4</li>
<li>nums is sorted in ascending order.</li>
<li>1 &lt;= n &lt;= 2^31 - 1</li>
</ul>
<h2 id=explanation>Explanation</h2>
<p>To solve this problem we need to add the required elements, so that we meet the given requirements. This is basically a extension of the <a href=https://leetcode.com/problems/maximum-number-of-consecutive-values-you-can-make/>1789. Maximum Number of Consecutive Values You Can Make</a>.</p>
<p>So the basic intuition behind solving this problem is, if we already selected some coins and these coins can cover upto [1, k] range, then if the next coin is</p>
<ul>
<li><strong>1</strong> we can select this coin so that the max range we can attain now increases to k + 1, i.e, [1, k + 1]</li>
<li><strong>k + 1</strong>, if we select this coin, that means we can make any number from 0 to k, so by just adding k to them, we can also make any number from k to k+(k+1) so, the range increases upto k + (k + 1), similarly for any coin which is less than k + 1.</li>
<li><strong>k + 2</strong> or greater than <strong>k + 2</strong>, if we select this coin, we can never achieve the value k + 1, so any value greater than k + 1, we cannot pick.</li>
</ul>
<p>So we sort all the given coins in increasing order, whenever we encounter the third case, then we <strong>greedily</strong> add the k + 1 coin and continue our calculation.</p>
<h2 id=code>Code</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
	<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
	<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
		<span style=color:#66d9ef>int</span> minPatches(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> n) {
			<span style=color:#66d9ef>int</span> patches <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

			<span style=color:#75715e>// this holds the current maximum 
</span><span style=color:#75715e></span>			<span style=color:#75715e>// range we can cover with the given coins
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
			
			<span style=color:#66d9ef>while</span>(i <span style=color:#f92672>&lt;</span> nums.size() <span style=color:#f92672>&amp;&amp;</span> k <span style=color:#f92672>&lt;</span> n){
				<span style=color:#75715e>// if we encounter the third case
</span><span style=color:#75715e></span>				<span style=color:#66d9ef>if</span>(nums[i] <span style=color:#f92672>&gt;</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>){
					<span style=color:#75715e>// greedily adding the k + 1 element
</span><span style=color:#75715e></span>					k <span style=color:#f92672>+=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;

					<span style=color:#75715e>// incrementing the number of patches done to the array
</span><span style=color:#75715e></span>					patches <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
				}
				<span style=color:#66d9ef>else</span> {

					<span style=color:#75715e>// for the first two cases we just add the 
</span><span style=color:#75715e></span>					<span style=color:#75715e>// current coin and keep procedding
</span><span style=color:#75715e></span>					k <span style=color:#f92672>+=</span> nums[i];
					i<span style=color:#f92672>++</span>;
				}
			}
			
			<span style=color:#75715e>// there might be a case where we added all the coins
</span><span style=color:#75715e></span>			<span style=color:#75715e>// but still we didn&#39;t reach the target
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>while</span>(k <span style=color:#f92672>&lt;</span> n){
				k <span style=color:#f92672>+=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
				patches <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
			}

			<span style=color:#66d9ef>return</span> patches;
		}
	};

</code></pre></div><h2 id=space-and-time-complexity>Space and Time Complexity</h2>
<p>N - number of coins
T - target given</p>
<ul>
<li>Space Complexity: O(1) - It is constant because, no matter the length of the input we only 3 variables.</li>
<li>Time Complexity: O(N + log(T - K)) - In the worst case, all the given coins are 1&rsquo;s and we need to iterate over the whole array and after that we need to add the next coin untill we reach the target, in this step the range is doubling (to be exact - k to 2k + 1), but for simplicity we can consider it to be doubled, so it will be log(T - K), where K is range after iterating over the given coins array.</li>
</ul>
</div>
</body>
</html>
<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>sleepingsaint | 01 Matrix</title>
<link rel=stylesheet href=https://sleepingsaint.github.io/blog/css/index.css>
</head>
<body>
<div class=navbar-container>
<h1>sleepingsaint</h1>
<div>
<a href=https://sleepingsaint.github.io/blog/>Home</a>
<a href=https://sleepingsaint.github.io/blog/posts/>Posts</a>
<a href=https://sleepingsaint.github.io/blog/series/>Series</a>
<a href=https://sleepingsaint.github.io/blog/tags/>Tags</a>
</div>
</div>
<div class=post-container>
<h2 id=question>Question</h2>
<p>Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.</p>
<p>The distance between two adjacent cells is 1.</p>
<h2 id=examples>Examples</h2>
<p>Input: mat = [[0,0,0],[0,1,0],[0,0,0]]</p>
<p>Output: [[0,0,0],[0,1,0],[0,0,0]]</p>
<hr>
<p>Input: mat = [[0,0,0],[0,1,0],[1,1,1]]</p>
<p>Output: [[0,0,0],[0,1,0],[1,2,1]]</p>
<h2 id=constraints>Constraints</h2>
<ul>
<li>m == mat.length</li>
<li>n == mat[i].length</li>
<li>1 &lt;= m, n &lt;= 104</li>
<li>1 &lt;= m * n &lt;= 104</li>
<li>mat[i][j] is either 0 or 1.</li>
<li>There is at least one 0 in mat.</li>
</ul>
<h2 id=explanation>Explanation</h2>
<p>Since the matrix is a 2 Dimensional space we can start searching from individual <strong>1&rsquo;s</strong> till we find a <strong>0</strong>. The distance along this path might be shortest distance or might not be. If it is we update the answer if not we break the search along the current path and do it another path.</p>
<p>I started the <strong>bfs (Breadth First Search)</strong> search from <strong>0&rsquo;s</strong> instead of <strong>1</strong> and updated the distances of <strong>1&rsquo;s</strong> if I encountered any. So we use <strong>queue</strong> data structure for the bfs. Once we are at an element be it either 1 or 0 we update all the neighbors and if any neighbor gets updated we push that neighbor into the queue and continue to update the path along that neighbor.</p>
<h2 id=code>Code</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
	<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
	<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
		vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> updateMatrix(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> mat) {
			<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> mat.size();
			<span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> mat[<span style=color:#ae81ff>0</span>].size();
			
			vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> ans(m, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(n, INT_MAX));
			
			<span style=color:#75715e>// initializing the queue 
</span><span style=color:#75715e></span>			queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> q;
			<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; i<span style=color:#f92672>++</span>){
				<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n; j<span style=color:#f92672>++</span>){
					<span style=color:#66d9ef>if</span>(mat[i][j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){
						ans[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
						q.push({i, j});
					}
				}
			}
			
			<span style=color:#75715e>// this 2 arrays can be used to 
</span><span style=color:#75715e></span>			<span style=color:#75715e>// loop through the adjacent cells
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>int</span> x[] <span style=color:#f92672>=</span> {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>};
			<span style=color:#66d9ef>int</span> y[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>};
			
			<span style=color:#75715e>// running the bfs untill all the answers are updated
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty()){
				pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> front <span style=color:#f92672>=</span> q.front();
				q.pop();
				
				<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> front.first, j <span style=color:#f92672>=</span> front.second;
				
				<span style=color:#75715e>// checking for all the adjacent neigbhours
</span><span style=color:#75715e></span>				<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; k<span style=color:#f92672>++</span>){
					<span style=color:#66d9ef>int</span> nei_i <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> x[k], nei_j <span style=color:#f92672>=</span> j <span style=color:#f92672>+</span> y[k];
					
					<span style=color:#75715e>// checking if the indexes are not out of limits 
</span><span style=color:#75715e></span>					<span style=color:#75715e>// and if the ans of the neigbhor is greater than the current ans
</span><span style=color:#75715e></span>					<span style=color:#75715e>// if the ans is already less we don&#39;t need to update the ans of the neighbor
</span><span style=color:#75715e></span>					<span style=color:#66d9ef>if</span>(nei_i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> nei_i <span style=color:#f92672>&gt;=</span> m <span style=color:#f92672>||</span> nei_j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> nei_j <span style=color:#f92672>&gt;=</span> n <span style=color:#f92672>||</span> ans[nei_i][nei_j] <span style=color:#f92672>&lt;</span> ans[i][j] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
						<span style=color:#66d9ef>continue</span>;
					ans[nei_i][nei_j] <span style=color:#f92672>=</span> ans[i][j] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
					q.push({nei_i, nei_j});
				}
			}
			
			<span style=color:#66d9ef>return</span> ans;
		}
	};

</code></pre></div><h2 id=space-and-time-complexity>Space and Time Complexity</h2>
<ul>
<li>Time Complexity: O(nm) - for iterating over all the nodes</li>
<li>Space Complexity: O(2nm)) - for storing the ans and at worst condition the whole matix is of 0&rsquo;s for queue stores all the nm nodes again hence 2(nm);</li>
</ul>
</div>
</body>
</html>
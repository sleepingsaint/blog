<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>sleepingsaint | Two Sum IV Input Is a Bst</title>
<link rel=stylesheet href=https://sleepingsaint.github.io/blog/css/index.css>
</head>
<body>
<div class=navbar-container>
<h1>sleepingsaint</h1>
<div>
<a href=https://sleepingsaint.github.io/blog/>Home</a>
<a href=https://sleepingsaint.github.io/blog/posts/>Posts</a>
<a href=https://sleepingsaint.github.io/blog/series/>Series</a>
<a href=https://sleepingsaint.github.io/blog/tags/>Tags</a>
</div>
</div>
<div class=post-container>
<h2 id=question>Question</h2>
<p>Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.</p>
<h2 id=examples>Examples</h2>
<p>Input: root = [5,3,6,2,4,null,7], k = 9 <br>
Output: true</p>
<hr>
<p>Input: root = [5,3,6,2,4,null,7], k = 28<br>
Output: false</p>
<hr>
<p>Input: root = [2,1,3], k = 4<br>
Output: true</p>
<hr>
<p>Input: root = [2,1,3], k = 1<br>
Output: false</p>
<hr>
<p>Input: root = [2,1,3], k = 3<br>
Output: true</p>
<h2 id=constraints>Constraints</h2>
<ul>
<li>The number of nodes in the tree is in the range [1, 104].</li>
<li>-104 &lt;= Node.val &lt;= 104</li>
<li>root is guaranteed to be a valid binary search tree.</li>
<li>-105 &lt;= k &lt;= 105</li>
</ul>
<h2 id=explanation>Explanation</h2>
<p>This problem is similar to any other two sum problem variant, but here we need to traverse a tree instead of an array. So one approach would be to first build the <strong>hashmap</strong> and then at every node we check if the counter part exists or not. In this approach we need to traverse the tree two times.</p>
<p>Another better approach would be to traverse the tree only once and compute the answer while traversing. We traverse the tree in a <strong>dfs</strong> approach. At every node we check if the counter exists or not, if not we add the current root value to the hashmap.</p>
<h2 id=code>Code</h2>
<h3 id=first-approach>First Approach</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
	<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
	<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
		<span style=color:#66d9ef>bool</span> findTarget(TreeNode<span style=color:#f92672>*</span> root, <span style=color:#66d9ef>int</span> k) {
			map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> count;
			<span style=color:#75715e>// building the hashmap recursively
</span><span style=color:#75715e></span>			buildCount(root, count);

			<span style=color:#75715e>// for every element in the hashmap
</span><span style=color:#75715e></span>			<span style=color:#75715e>// or in other words every node in the tree
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> it: count){
				<span style=color:#66d9ef>int</span> val <span style=color:#f92672>=</span> it.first;
				<span style=color:#66d9ef>int</span> rem <span style=color:#f92672>=</span> k <span style=color:#f92672>-</span> val;
				
				<span style=color:#75715e>// decrementing because there might be duplicate values in bst
</span><span style=color:#75715e></span>				<span style=color:#75715e>// since its not clear in the question in that case we might get wrong
</span><span style=color:#75715e></span>				<span style=color:#75715e>// answer for some situtations
</span><span style=color:#75715e></span>
				<span style=color:#75715e>// for example: k = 4, curr node = 2, count[2] = 1
</span><span style=color:#75715e></span>				<span style=color:#75715e>// in the above example if we don&#39;t decrement we would the answer 
</span><span style=color:#75715e></span>				<span style=color:#75715e>// as right but in reality we have only one 2 in the tree
</span><span style=color:#75715e></span>				count[val]<span style=color:#f92672>--</span>;
				
				<span style=color:#75715e>// checking the if the counter part exists
</span><span style=color:#75715e></span>				<span style=color:#66d9ef>if</span>(count.find(rem) <span style=color:#f92672>!=</span> count.end() <span style=color:#f92672>&amp;&amp;</span> count[rem] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>){
					<span style=color:#66d9ef>return</span> true;
				}
				count[val]<span style=color:#f92672>++</span>;
			}
			<span style=color:#66d9ef>return</span> false;
		}
		
		<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>buildCount</span>(TreeNode<span style=color:#f92672>*</span> root, map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>count){
			<span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>root) <span style=color:#66d9ef>return</span>;
			<span style=color:#75715e>// add the root val to the hashmap
</span><span style=color:#75715e></span>			count[root<span style=color:#f92672>-&gt;</span>val]<span style=color:#f92672>++</span>;

			<span style=color:#75715e>// build the map for left and right subtrees
</span><span style=color:#75715e></span>			buildCount(root<span style=color:#f92672>-&gt;</span>left, count);
			buildCount(root<span style=color:#f92672>-&gt;</span>right, count);
		}
	};

</code></pre></div><h3 id=second-efficient-approach>Second (Efficient) Approach</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
	<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
	<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
		<span style=color:#75715e>// hashmap to store the visited nodes
</span><span style=color:#75715e></span>		unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m;
		
		<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>findTarget</span>(TreeNode<span style=color:#f92672>*</span> root, <span style=color:#66d9ef>int</span> k) {
			<span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>root) <span style=color:#66d9ef>return</span> false;
			<span style=color:#75715e>// checking if the counter part exists or not
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span>(m.find(k <span style=color:#f92672>-</span> root<span style=color:#f92672>-&gt;</span>val) <span style=color:#f92672>!=</span> m.end())
				<span style=color:#66d9ef>return</span> true;

			<span style=color:#75715e>// adding the root value to the hashmap
</span><span style=color:#75715e></span>			m[root<span style=color:#f92672>-&gt;</span>val]<span style=color:#f92672>++</span>;
			<span style=color:#75715e>// recursively computing the answer
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> findTarget(root<span style=color:#f92672>-&gt;</span>left, k) <span style=color:#f92672>||</span> findTarget(root<span style=color:#f92672>-&gt;</span>right, k);
		}
	};

</code></pre></div><h2 id=space-and-time-complexity>Space and Time Complexity</h2>
<p>N - total number of nodes in the tree</p>
<ul>
<li>Space Complexity: O(N) - for hashmap to store the nodes. In the worst case we find the answer in the last leaf node, so hashmap stores all the nodes</li>
<li>Time Complexity: O(N) - In worst case the BST is a skewed tree so we visit every node atleast once.</li>
</ul>
</div>
</body>
</html>